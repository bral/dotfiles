#!/usr/bin/env zsh
# System Update Script v2.1 (Fail-Safe)
# Parallelized updates with visible errors and graceful failure handling
set -e

# Colors
BLUE='\033[0;34m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

info() { echo -e "${BLUE}â„¹${NC} $1"; }
ok() { echo -e "${GREEN}âœ“${NC} $1"; }
warn() { echo -e "${YELLOW}âš ${NC} $1"; }
error() { echo -e "${RED}âœ—${NC} $1" >&2; }

# PID storage for background tasks
typeset -a PIDS
typeset -A TASKS

# Helper to run function in background
async_run() {
    local func=$1
    local name=$2
    info "Starting: $name..."
    ( $func ) &
    PIDS+=($!)
    TASKS[$!]=$name
}

# --- Update Functions ---

update_brew() {
    # Brew locks its own database, so it must run alone or alongside non-brew tasks
    if command -v brew &>/dev/null; then
        brew update || warn "brew update failed"
        brew upgrade || warn "brew upgrade failed"
        brew cleanup || warn "brew cleanup failed"
    fi
}

update_mise() {
    # Mise is safe to run parallel to brew
    if command -v mise &>/dev/null; then
        mise upgrade || warn "mise upgrade failed"
        mise self-update -y || warn "mise self-update failed"
    fi
}

update_clis() {
    # Group fast CLI updates here

    # 1. Node tools (pnpm)
    if command -v pnpm &>/dev/null; then
        # "|| true" prevents script crash if this fails
        pnpm update -g || warn "pnpm update failed"
    fi

    # 2. Python tools (pipx is better than global pip)
    if command -v pipx &>/dev/null; then
        pipx upgrade-all --include-injected || warn "pipx upgrade failed"
    elif command -v pip &>/dev/null; then
        # Use sudo if not in a venv, or warn user
        pip install -U pip || warn "pip update failed (permissions?)"
    fi

    # 3. Claude Code
    if command -v npm &>/dev/null; then
         # Removed 2>/dev/null so you can see the error
         # Added || warn so it doesn't crash the whole script
         npm update -g @anthropic-ai/claude-code || warn "Claude Code update failed"
    fi
}

update_go_tools() {
    # These compile from source, so they are slow. Run in background.
    if command -v go &>/dev/null; then
        # FIX: Point to /cmd/fabric (where the actual binary lives)
        go install github.com/danielmiessler/fabric/cmd/fabric@latest || warn "Fabric install failed"
        go install github.com/gofast-live/gofast-cli/cmd/gofast@latest || warn "GoFast install failed"
    fi
}

update_spacevim() {
    if [[ -d "$HOME/.SpaceVim" ]]; then
        git -C "$HOME/.SpaceVim" pull || warn "SpaceVim git pull failed"
        # Only run nvim update if nvim exists (headless mode prevents UI hangs)
        if command -v nvim &>/dev/null; then
             nvim --headless +SPUpdate +qall || warn "SpaceVim plugin update failed"
        fi
    fi
}

check_macos() {
    if softwareupdate -l 2>/dev/null | grep -q "No new software"; then
        ok "macOS up to date"
    else
        warn "macOS updates available (Run: softwareupdate -i -a)"
    fi
}

# --- Main Execution ---

full_update() {
    info "ðŸš€ Starting Full System Update..."
    echo ""

    # 1. Start the heavy hitters in parallel
    # Brew is IO heavy, Go is CPU heavy. They usually play nice together.

    async_run update_brew "Homebrew (System Packages)"
    async_run update_mise "Mise (Runtimes)"
    async_run update_clis "CLIs (Node, Pipx, Claude)"
    async_run update_go_tools "Go Tools (Fabric, GoFast)"
    async_run update_spacevim "SpaceVim"

    # 2. Wait for all to finish
    local fail_count=0
    for pid in ${PIDS}; do
        if wait $pid; then
            ok "${TASKS[$pid]} updated"
        else
            error "${TASKS[$pid]} failed"
            ((fail_count++))
        fi
    done

    # 3. macOS check (fast, synchronous)
    echo ""
    check_macos

    echo ""
    if [[ $fail_count -eq 0 ]]; then
        ok "âœ¨ System update complete!"
    else
        error "âš ï¸ Update completed with $fail_count errors"
    fi
}

quick_update() {
    info "Running quick update (Brew + Mise only)..."
    async_run update_brew "Homebrew"
    async_run update_mise "Mise"

    local fail_count=0
    for pid in ${PIDS}; do
        if wait $pid; then
            ok "${TASKS[$pid]} updated"
        else
            error "${TASKS[$pid]} failed"
            ((fail_count++))
        fi
    done

    if [[ $fail_count -eq 0 ]]; then
        ok "Quick update complete"
    else
        error "Quick update completed with $fail_count errors"
    fi
}

check_updates() {
    info "Checking for available updates..."
    echo ""

    echo "Homebrew:"
    brew outdated

    echo ""
    echo "Mise:"
    command -v mise &>/dev/null && mise outdated || echo "mise not installed"

    echo ""
    echo "pnpm:"
    command -v pnpm &>/dev/null && pnpm outdated -g || echo "pnpm not installed"

    echo ""
    echo "pipx:"
    command -v pipx &>/dev/null && pipx list --short || echo "pipx not installed"

    echo ""
    echo "macOS:"
    softwareupdate -l
}

show_help() {
    echo "System Update Script v2.1"
    echo ""
    echo "Usage: $(basename $0) [full|quick|check|help]"
    echo ""
    echo "Commands:"
    echo "  full   - Update everything (default) - runs in parallel"
    echo "  quick  - Update brew and mise only - fast"
    echo "  check  - Show what needs updating"
    echo "  help   - Show this help message"
    echo ""
    echo "Changes in v2.1:"
    echo "  â€¢ Improved error visibility - see what actually fails"
    echo "  â€¢ Fail-safe mode - one failure won't crash entire update"
    echo "  â€¢ Better error messages with specific failure reasons"
    echo ""
    echo "Changes in v2.0:"
    echo "  â€¢ Parallelized updates (Brew + Mise + CLIs + Go + SpaceVim)"
    echo "  â€¢ Removed FZF update (handled by Homebrew)"
    echo "  â€¢ Removed Starship redundancy (handled by brew upgrade)"
    echo "  â€¢ Added pipx support for Python tools"
    echo "  â€¢ Fixed nvim headless mode"
}

# Argument handling
case "${1:-full}" in
    full|all|"") full_update ;;
    quick) quick_update ;;
    check) check_updates ;;
    help|-h|--help) show_help ;;
    *)
        echo "Unknown command: $1" >&2
        show_help
        exit 1
        ;;
esac
